<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>åŠ¨æ€è¡¨æƒ… - é»„è‰²ï¼ˆç‚¹å‡»å‘é€120Â°ï¼‰</title>
  <style>
    :root {
      --line-thickness: 10px;
      --eye-height: 35px;
      --face-color: transparent; /* åˆå§‹é€æ˜ */
      --max-move-distance: 30px;
      --max-squeeze-scale: 0.90;
      --max-stretch-scale: 1.05;
      --face-shift-ratio: 0.15;
      --face-padding: 50px;
    }

    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #FFFFFF;
      padding: var(--face-padding);
      box-sizing: border-box;
      position: relative;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "PingFang SC", "Noto Sans CJK SC", "Microsoft YaHei", sans-serif;
    }

    .emoji-container {
      width: 80vw;
      max-width: 300px;
      height: auto;
      aspect-ratio: 1 / 1;

      background-color: var(--face-color);
      border-radius: 50%;
      position: relative;
      box-shadow: none;
      cursor: pointer;

      transition: transform 0.1s ease-out, box-shadow 0.1s ease-out, background-color 0.5s ease;
      overflow: hidden;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .features-wrapper {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transition: transform 0.1s ease-out;
      opacity: 1;
    }

    .eye, .mouth {
      position: absolute;
      background-color: black;
    }

    .eye {
      width: var(--line-thickness);
      height: var(--eye-height);
      top: 35%;
      animation: blink 4s infinite;
    }

    .left-eye {
      left: 35%;
      transform: translateX(-50%);
    }

    .right-eye {
      right: 35%;
      transform: translateX(50%);
    }

    .mouth {
      width: 80px;
      height: 80px;
      border: var(--line-thickness) solid black;
      border-color: transparent transparent black transparent;
      border-radius: 50%;
      bottom: 25%;
      right: 30%;
      transform: rotate(-45deg);
      background-color: transparent;
    }

    @keyframes blink {
      0%, 45%, 100% {
        height: var(--eye-height);
        transform: translateX(-50%);
      }
      50%, 52% {
        height: var(--line-thickness);
        transform: translate(-50%, calc((var(--eye-height) - var(--line-thickness)) / 2));
      }
    }

    @keyframes shake {
      0% { transform: scale(1.0); }
      50% { transform: scale(0.98); }
      100% { transform: scale(1.0); }
    }

    .click-shake {
      animation: shake 0.2s ease-in-out;
    }
  </style>
</head>

<body>
  <!-- âœ… äº¤äº’è¾“å…¥ï¼šç‚¹å‡»è¿™ä¸ªåœ†è„¸ -->
  <div class="emoji-container" id="emojiContainer" aria-label="yellow emoji">
    <div class="features-wrapper" id="featuresWrapper">
      <div class="eye left-eye"></div>
      <div class="eye right-eye"></div>
      <div class="mouth"></div>
    </div>
  </div>

  <script>
    const container = document.getElementById('emojiContainer');
    const wrapper   = document.getElementById('featuresWrapper');
    const root      = document.documentElement;

    // ===================== é¢œè‰²ä¸çŠ¶æ€ï¼ˆé»„è‰²ï¼‰ =====================
    const TARGET_HUE        = 55;   // ğŸŸ¡ é»„è‰²
    const TARGET_SATURATION = 100;
    const TARGET_LIGHTNESS  = 70;

    const MAX_CLICKS = 10;
    const DECAY_DURATION_SEC = 30;
    const DECAY_RATE_PER_SEC = MAX_CLICKS / DECAY_DURATION_SEC;

    let clickCount = 0;
    let decayInterval = null;

    // ä» CSS è¯»å–äº¤äº’å‚æ•°
    const maxDistance      = parseFloat(getComputedStyle(root).getPropertyValue('--max-move-distance')) || 30;
    const maxSqueezeScale  = parseFloat(getComputedStyle(root).getPropertyValue('--max-squeeze-scale')) || 0.90;
    const maxStretchScale  = parseFloat(getComputedStyle(root).getPropertyValue('--max-stretch-scale')) || 1.05;
    const faceShiftRatio   = parseFloat(getComputedStyle(root).getPropertyValue('--face-shift-ratio')) || 0.15;

    // ===================== Blynk é…ç½®ï¼ˆæ¯æ¬¡ç‚¹å‡»å‘é€ 120Â°ï¼‰ =====================
    const AUTH_TOKEN   = 'OqSFS2EppKQRi0DYBOTFNEQgW7pljRjT';
    const BLYNK_HOST   = 'blynk.cloud';
    const VIRTUAL_PIN  = 'V1';

    const PICKUP_ANGLE = 120; // âœ… ä½ è¦çš„è¾“å‡ºï¼š120
    const RETURN_ANGLE = 0;   // å‘é€åå¤ä½ä¸º 0ï¼ˆç”¨äºâ€œè„‰å†²â€è§¦å‘ï¼‰

    async function sendCommand(value) {
      const urlPush  = `https://${BLYNK_HOST}/external/api/update?token=${AUTH_TOKEN}&${VIRTUAL_PIN}=${value}`;
      const urlReset = `https://${BLYNK_HOST}/external/api/update?token=${AUTH_TOKEN}&${VIRTUAL_PIN}=${RETURN_ANGLE}`;

      console.log('[Blynk] sending', value);

      try {
        // Step 1: PUSH 120
        const r1 = await fetch(urlPush);
        if (!r1.ok) {
          console.error('[Blynk] PUSH failed', r1.status);
          return;
        }

        // Step 2: RESET 0ï¼ˆè®©ä¸‹ä¸€æ¬¡ç‚¹å‡»ä»ç„¶èƒ½è§¦å‘ï¼‰
        const r2 = await fetch(urlReset);
        if (!r2.ok) {
          console.error('[Blynk] RESET failed', r2.status);
        } else {
          console.log('[Blynk] done, reset to 0');
        }
      } catch (e) {
        console.error('[Blynk] network error', e);
      }
    }

    // ===================== çŠ¶æ€å­˜å‚¨ï¼ˆé¢œè‰²è®°å¿†ï¼‰ =====================
    function saveState() {
      localStorage.setItem('emojiClickCount', clickCount);
      localStorage.setItem('emojiLastUpdateTime', Date.now());
    }

    function updateColor() {
      const progress = clickCount / MAX_CLICKS; // 0..1

      const currentSaturation = Math.round(TARGET_SATURATION * progress);
      const currentLightness  = Math.round(100 - (100 - TARGET_LIGHTNESS) * progress);

      if (progress === 0) {
        root.style.setProperty('--face-color', 'transparent');
        container.style.boxShadow = 'none';
      } else {
        const hslColor = `hsl(${TARGET_HUE}, ${currentSaturation}%, ${currentLightness}%)`;
        root.style.setProperty('--face-color', hslColor);

        const shadowOffsetY = 4 * progress;
        const shadowBlur    = 15 + 10 * progress;
        const shadowOpacity = 0.1 + 0.2 * progress;

        container.style.boxShadow = `0 ${shadowOffsetY}px ${shadowBlur}px 0 rgba(0, 0, 0, ${shadowOpacity})`;
      }
    }

    function updateDecay() {
      if (clickCount <= 0) {
        clickCount = 0;
        clearInterval(decayInterval);
        decayInterval = null;
        updateColor();
        saveState();
        return;
      }

      const stepsToDecay = 1 * DECAY_RATE_PER_SEC;
      clickCount = Math.max(0, clickCount - stepsToDecay);

      updateColor();
      saveState();
    }

    // ===================== âœ… ç‚¹å‡»ï¼šæ¯æ¬¡éƒ½å‘é€ 120Â° =====================
    function handleClickEffect() {
      container.classList.remove('click-shake');
      void container.offsetWidth;
      container.classList.add('click-shake');

      // é¢œè‰²è®°å¿†
      clickCount = Math.min(MAX_CLICKS, clickCount + 1);
      updateColor();
      saveState();

      // âœ… æ¯ç‚¹å‡»ä¸€ä¸‹ï¼šè¾“å‡º 120
      sendCommand(PICKUP_ANGLE);

      if (!decayInterval) {
        decayInterval = setInterval(updateDecay, 1000);
      }
    }

    // ===================== è·Ÿéšç§»åŠ¨ï¼ˆè¡¨æƒ…è·Ÿæ‰‹ï¼‰ =====================
    function handleInteraction(event) {
      event.preventDefault();

      container.classList.remove('click-shake');

      const clientX = event.clientX || (event.touches ? event.touches[0].clientX : undefined);
      const clientY = event.clientY || (event.touches ? event.touches[0].clientY : undefined);
      if (clientX === undefined || clientY === undefined) return;

      const rect = container.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top  + rect.height / 2;

      let dx = clientX - cx;
      let dy = clientY - cy;

      const dist = Math.sqrt(dx * dx + dy * dy);
      let moveX = dx;
      let moveY = dy;

      if (dist > maxDistance) {
        const ratio = maxDistance / dist;
        moveX = dx * ratio;
        moveY = dy * ratio;
      }

      const faceMoveX = moveX * -faceShiftRatio;
      const faceMoveY = moveY * -faceShiftRatio;
      container.style.transform = `translate(${faceMoveX}px, ${faceMoveY}px)`;

      let scaleX = 1;
      if (Math.abs(moveX) > Math.abs(moveY)) {
        const hr = Math.abs(moveX) / maxDistance;
        scaleX = 1 - (1 - maxSqueezeScale) * hr;
      } else if (Math.abs(moveY) > 0.01) {
        const vr = Math.abs(moveY) / maxDistance;
        scaleX = 1 + (maxStretchScale - 1) * vr;
      }

      let scaleY = 1;
      if (Math.abs(moveY) > Math.abs(moveX)) {
        const vr = Math.abs(moveY) / maxDistance;
        scaleY = 1 - (1 - maxSqueezeScale) * vr;
      } else if (Math.abs(moveX) > 0.01) {
        const hr = Math.abs(moveX) / maxDistance;
        scaleY = 1 + (maxStretchScale - 1) * hr;
      }

      wrapper.style.transform = `translate(${moveX}px, ${moveY}px) scaleX(${scaleX}) scaleY(${scaleY})`;
    }

    function resetPosition() {
      wrapper.style.transform = 'translate(0, 0) scaleX(1) scaleY(1)';
      container.style.transform = 'translate(0, 0)';
      container.classList.remove('click-shake');
    }

    // ===================== åˆå§‹åŒ–ï¼ˆé¢œè‰²è®°å¿† + è¡°å‡ï¼‰ =====================
    function initializeState() {
      const savedCount  = localStorage.getItem('emojiClickCount');
      const lastUpdate  = localStorage.getItem('emojiLastUpdateTime');
      const now = Date.now();

      if (savedCount && lastUpdate) {
        const initialCount = parseFloat(savedCount);
        const elapsedSec = (now - parseInt(lastUpdate, 10)) / 1000;
        const decayAmount = elapsedSec * DECAY_RATE_PER_SEC;
        clickCount = Math.max(0, initialCount - decayAmount);
      } else {
        clickCount = 0;
      }

      updateColor();

      if (clickCount > 0) {
        decayInterval = setInterval(updateDecay, 1000);
      }
    }

    // --- å¯åŠ¨ ---
    initializeState();

    // --- ç»‘å®šäº‹ä»¶ ---
    document.addEventListener('mousemove', handleInteraction, { passive: false });
    document.addEventListener('touchmove', handleInteraction, { passive: false });

    container.addEventListener('click', handleClickEffect);
    container.addEventListener('touchstart', (e) => { e.preventDefault(); handleClickEffect(); }, { passive: false });

    document.addEventListener('mouseup', resetPosition);
    document.addEventListener('touchend', resetPosition);
    document.addEventListener('touchcancel', resetPosition);

    container.addEventListener('contextmenu', (e) => e.preventDefault());
  </script>
</body>
</html>
