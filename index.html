<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>动态表情 - 脸部同步微移与粒子特效</title>
    <style>
        /* 统一线条粗细变量 */
        :root {
            --line-thickness: 10px;
            --eye-height: 35px;
            --face-color: #ffb6a3;
            --max-move-distance: 30px; 
            --max-squeeze-scale: 0.90; 
            --max-stretch-scale: 1.05;
            --face-shift-ratio: 0.15; 
            --face-padding: 50px; 
        }
        
        /* 1. 页面整体样式 */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            display: flex; 
            justify-content: center;
            align-items: center;
            background-color: #f0f0f0; 
            padding: var(--face-padding);
            box-sizing: border-box; 
            /* 确保粒子能在整个视口内显示 */
            position: relative; 
            overflow: hidden; /* 防止粒子超出页面引起滚动条 */
        }

        /* 2. 表情容器 (大圆脸) */
        .emoji-container {
            width: 80vw;
            max-width: 300px; 
            height: 80vw;
            max-height: 300px;
            background-color: var(--face-color);
            border-radius: 50%; 
            position: relative;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); 
            cursor: pointer;
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out; 
            overflow: hidden; /* 隐藏五官超出脸部容器的部分 */
            z-index: 10; /* 确保表情在粒子上方 */
        }
        
        /* 3. 五官容器 (内部移动层) */
        .features-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transition: transform 0.1s ease-out; 
        }

        /* 4. 眼睛和嘴巴的通用样式 */
        .eye, .mouth {
            position: absolute;
            background-color: black;
        }

        /* 5. 眼睛、嘴巴、眨眼动画等样式 (保持不变) */
        .eye {
            width: var(--line-thickness); 
            height: var(--eye-height); 
            top: 35%; 
            animation: blink 4s infinite; 
        }

        .left-eye {
            left: 35%;
            transform: translateX(-50%);
        }

        .right-eye {
            right: 35%;
            transform: translateX(50%);
        }

        .mouth {
            width: 80px;
            height: 80px;
            border: var(--line-thickness) solid black; 
            border-color: transparent transparent black transparent; 
            border-radius: 50%;
            bottom: 25%;
            right: 30%; 
            transform: rotate(-45deg); 
            background-color: transparent; 
        }
        
        @keyframes blink {
            0%, 45%, 100% {
                height: var(--eye-height);
                transform: translateX(-50%); 
            }
            50%, 52% {
                height: var(--line-thickness);
                transform: translate(-50%, calc((var(--eye-height) - var(--line-thickness)) / 2));
            }
        }
        
        /* --- 粒子特效相关 CSS --- */
        #particle-container {
            position: absolute; /* 相对于 body 定位 */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* 确保粒子容器不会阻挡点击事件 */
            z-index: 5; /* 确保粒子在表情下方或特定层级 */
        }

        .particle {
            position: absolute;
            background-color: #f7e2a9; /* 粒子颜色，可以随机 */
            border-radius: 50%; /* 圆形粒子 */
            opacity: 0; /* 初始透明 */
            animation: explode 1s forwards; /* 爆炸动画 */
        }

        @keyframes explode {
            0% {
                transform: scale(0.2); /* 初始小 */
                opacity: 1; /* 初始完全不透明 */
            }
            100% {
                transform: translate(var(--x), var(--y)) scale(1.5); /* 向外扩散并放大 */
                opacity: 0; /* 最终完全透明 */
            }
        }
    </style>
</head>
<body>
    <div class="emoji-container" id="emojiContainer">
        <div class="features-wrapper" id="featuresWrapper">
            <div class="eye left-eye"></div>
            <div class="eye right-eye"></div>
            <div class="mouth"></div>
        </div>
    </div>
    
    <div id="particle-container"></div>

    <script>
        const container = document.getElementById('emojiContainer'); // 使用ID获取，更精确
        const wrapper = document.getElementById('featuresWrapper');
        const particleContainer = document.getElementById('particle-container');
        
        // 读取 CSS 变量
        const maxDistance = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--max-move-distance')) || 30;
        const maxSqueezeScale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--max-squeeze-scale')) || 0.90;
        const maxStretchScale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--max-stretch-scale')) || 1.05;
        const faceShiftRatio = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--face-shift-ratio')) || 0.15;


        // 统一处理鼠标点击/触摸事件 (用于五官位移和聚拢)
        function handleInteraction(event) {
            event.preventDefault();

            const clientX = event.clientX || (event.touches ? event.touches[0].clientX : event.clientX);
            const clientY = event.clientY || (event.touches ? event.touches[0].clientY : event.clientY);
            
            if (clientX === undefined || clientY === undefined) return;

            const containerRect = container.getBoundingClientRect();
            const containerCenterX = containerRect.left + containerRect.width / 2;
            const containerCenterY = containerRect.top + containerRect.height / 2;
            
            let dx = clientX - containerCenterX;
            let dy = clientY - containerCenterY;

            const distance = Math.sqrt(dx * dx + dy * dy);
            let moveX = dx;
            let moveY = dy;
            
            if (distance > maxDistance) {
                const ratio = maxDistance / distance;
                moveX = dx * ratio;
                moveY = dy * ratio;
            }

            const faceMoveX = moveX * -faceShiftRatio; 
            const faceMoveY = moveY * -faceShiftRatio; 
            
            container.style.transform = `translate(${faceMoveX}px, ${faceMoveY}px)`;
            
            const maxAbsMove = Math.max(Math.abs(moveX), Math.abs(moveY)); 
            const maxMoveRatio = maxAbsMove / maxDistance; 
            
            let scaleX = 1;
            if (Math.abs(moveX) > Math.abs(moveY)) {
                const horizontalRatio = Math.abs(moveX) / maxDistance;
                scaleX = 1 - (1 - maxSqueezeScale) * horizontalRatio; 
            } else if (Math.abs(moveY) > 0.01) {
                const verticalRatio = Math.abs(moveY) / maxDistance;
                scaleX = 1 + (maxStretchScale - 1) * verticalRatio;
            }

            let scaleY = 1;
            if (Math.abs(moveY) > Math.abs(moveX)) {
                const verticalRatio = Math.abs(moveY) / maxDistance;
                scaleY = 1 - (1 - maxSqueezeScale) * verticalRatio; 
            } else if (Math.abs(moveX) > 0.01) {
                const horizontalRatio = Math.abs(moveX) / maxDistance;
                scaleY = 1 + (maxStretchScale - 1) * horizontalRatio;
            }
            
            wrapper.style.transform = `translate(${moveX}px, ${moveY}px) scaleX(${scaleX}) scaleY(${scaleY})`;
        }

        // --- 粒子生成函数 ---
        function createParticles(x, y) {
            const numParticles = 15; // 每次点击生成的粒子数量
            const particleSize = 8; // 粒子大小

            for (let i = 0; i < numParticles; i++) {
                const particle = document.createElement('div');
                particle.classList.add('particle');
                
                // 随机设置粒子初始位置在点击点附近
                const startX = x - particleSize / 2 + (Math.random() - 0.5) * 10;
                const startY = y - particleSize / 2 + (Math.random() - 0.5) * 10;
                
                particle.style.width = `${particleSize}px`;
                particle.style.height = `${particleSize}px`;
                particle.style.left = `${startX}px`;
                particle.style.top = `${startY}px`;

                // 随机生成粒子的最终扩散方向和距离
                const angle = Math.random() * Math.PI * 2; // 0到2PI (360度)
                const distance = Math.random() * 80 + 50; // 扩散距离 50px 到 130px
                const endX = Math.cos(angle) * distance;
                const endY = Math.sin(angle) * distance;

                // 使用 CSS 变量传递动画参数
                particle.style.setProperty('--x', `${endX}px`);
                particle.style.setProperty('--y', `${endY}px`);

                particleContainer.appendChild(particle);

                // 动画结束后移除粒子 (防止DOM元素过多)
                particle.addEventListener('animationend', () => {
                    particle.remove();
                });
            }
        }

        // --- 监听表情容器的点击事件 (用于生成粒子) ---
        container.addEventListener('click', (event) => {
            // 获取点击点相对于文档的坐标
            const clickX = event.clientX;
            const clickY = event.clientY;
            
            createParticles(clickX, clickY);
        });
        container.addEventListener('touchstart', (event) => {
            // 在触摸开始时也生成粒子
            const touchX = event.touches[0].clientX;
            const touchY = event.touches[0].clientY;
            createParticles(touchX, touchY);
        }, { passive: true }); // passive: true 提升触摸事件性能


        // 绑定事件： (五官位移和聚拢)
        document.addEventListener('mousemove', handleInteraction);
        document.addEventListener('touchmove', handleInteraction);
        
        // 当鼠标/手指抬起时，五官和脸部复位
        function resetPosition() {
             wrapper.style.transform = 'translate(0, 0) scaleX(1) scaleY(1)';
             container.style.transform = 'translate(0, 0)';
        }
        document.addEventListener('mouseup', resetPosition);
        document.addEventListener('touchend', resetPosition);
        document.addEventListener('touchcancel', resetPosition);

    </script>
</body>
</html>
